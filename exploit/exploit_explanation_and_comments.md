## Exploit explanation

Calling the function `is_entity_registered` with the input `num_entities_storage` returns a true value (i.e. it returns the felt 1) (assuming there is at least one other entity which is part of the network). Hence an attacking entity who is not part of the network can give itself the name `num_entities_storage` and access the contract's functionality since it will appear as a registered entity.

The reason why this happens is because the StakNet OS stores a variable with name `variable_name` in the cell `sn_keccak256(variable_name)`. Hence, as long as `num_entities_storage` is more than 0, `is_entity_registered(num_entitites_storage)` will return 1 because `storage_read(sn_keccak(num_entitties_storage)) > 0`. 

A similar bug occurs for each storage_variable in the contract that does not accept arguments (i.e. if the contract has a 0-argument variable named "foo", then the entity "foo" will appear as registered in the system).

**NOTE:** The malicious entity with name `"num_entities_storage"` appears as registired, but it will not be encountered when iterating thorugh the ...

## Possible patches
Any of the following patches would fix the bug described above.
### Patch 1
Instead of assigning `sn_keccak256("entity_name")` as the memory cell where the corresponding `EntityInfo` begins, one can use a storage_variable as follows:

        @storage_var
        func entity_name_to_entity_info(entity_name : felt) -> (entity_info : EntityInfo):
        end

This way, instead of storing `EntityInfo` starting at `sn_keccak256("entity_name")`, we store `EntityInfo` starting at `pedersen_hash(sn_keccak256("entity_name_to_entity_info"), entity_name)`. Now, a similar attack as the one described above is infeasible since it would require finding a collision for the Pedersen hash.

**NOTE 1:** This method is possibly more natural than the bugged approach provided by us. However we think that it is not unreasonable for someone to decide to implement the bugged version because the bugged version performs slightly less computations of hashes: on the one hand the calculation of the memory cell uses more hash calls in the non-bugged method, and on the other hand in the non-bugged method the natural thing would be to make the variable `entity_index_to_entity_memory_cell` be actually  `entity_index_to_entity_name` (recall that we need some kind of "list" that we can use to "iterate" over all entity informations), so if we were to access the EntityInfo having only the entity_index, then the non-bugged method will have the extra step of computing the memory cell assigned to the entity name, while in the bugged version this extra computation is not needed.

**NOTE 2:** In the case that the index associated to an entity is immutable, there are simpler implementations of the contract. However we have assumed that the index may change over time. 


### Patch 2 
When selecting the memory cells where to store the entity information, use the Pedersen hash function instead of `sn_keccak256`, i.e. for an entity with name `entity_name`, store the struct `EntityInfo` in `pedersen_hash(0, "entity_name")`.

