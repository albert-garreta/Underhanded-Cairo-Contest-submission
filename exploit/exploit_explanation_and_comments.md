## Exploit explanation

Calling the function `is_entity_registered` with the input `num_entities_storage` returns a true value (i.e. it returns the felt 1) (assuming there is at least one other entity which is part of the network). Hence an attacking entity who is not part of the network can give itself the name `num_entities_storage` and access some of the network's privileges since it will appear as a registered entity. *********** NOTE: the privileges of appearing as registered are not written in the contract, but 

The reason why this happens is because the StakNet OS stores a "variable" with name `variable_name` at the cell `sn_keccak256(variable_name)` (***reference***). Hence, as long as `num_entities_storage` is more than 0, `is_entity_registered(num_entitites_storage)` will return 1 because `storage_read(sn_keccak(num_entitties_storage)) > 0`. 

Similarly, for each 0-argument storage variable "foo" in the contract, we have that the entity with name "foo" will be accepted as registered in the system.

**NOTE:** The malicious entity with name `"num_entities_storage"` appears as registired, but it will not be encountered when iterating thorugh the ...

## Possible patches
Any of the following patches would fix the bug described above. 
### Patch 1
Instead of assigning `sn_keccak256("entity_name")` as the memory cell where the corresponding instance of `EntityInfo` begins, one can use a storage_variable as follows:

        @storage_var
        func entity_name_to_entity_info(entity_name : felt) -> (entity_info : EntityInfo):
        end

This way, instead of storing the instance of `EntityInfo` starting at the cell `sn_keccak256("entity_name")`, the instance of `EntityInfo` is stored starting at `pedersen_hash(sn_keccak256("entity_name_to_entity_info"), "entity_name")` (this is how StarkNet stores variables that accept one argument ***references***). Now, a similar attack as the one described above is infeasible since ....*******.... it would require finding a collision for the Pedersen hash.

**NOTE 1:** This method is possibly more natural than the bugged approach provided by us. However I ****we?**** think that it is not unreasonable for someone to decide to implement the bugged version because the bugged version performs slightly less computations of hashes. For completeness, in the next paragraph we briefly explain why the this is so.

*Efficiency of bugged approach:* On the one hand the calculation of the memory cell uses more hash calls in the non-bugged method, and on the other hand in the non-bugged method the natural thing would be to make the variable `entity_index_to_entity_memory_cell` be actually  `entity_index_to_entity_name` (recall that we need some kind of "list" that we can use to "iterate" over all entity informations), so if we were to access the EntityInfo having only the entity_index, then the non-bugged method will have the extra step of computing the memory cell assigned to the entity name, while in the bugged version this extra computation is not needed.

**NOTE 2:** In the case that the index associated to an entity is immutable, there are simpler implementations of the contract. However we have assumed that the index may change over time. 


### Patch 2 
When selecting the memory cells where to store the entity information, use the Pedersen hash function instead of `sn_keccak256`, i.e. for an entity with name `entity_name`, store the struct `EntityInfo` in `pedersen_hash(0, "entity_name")`.

