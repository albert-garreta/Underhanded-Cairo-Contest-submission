## Exploit explanation

Calling the function `is_entity_registered` with the input `num_entities_storage` returns a true value (i.e. it returns the felt 1) (assuming there is at least one other entity which is part of the network). Hence an attacking entity who is not part of the network can give itself the name `num_entities_storage` and access the contract's functionality since it will appear as a registered entity.

The reason why this happens is because the StakNet OS stores a variable with name `variable_name` is stored in the cell `sn_keccak256(variable_name)`. Hence, as long as `num_entities_storage` is more than 0, `is_entity_registered(num_entitites_storage)` will return 1 because  `storage_read(sn_keccak(num_entitties_storage)) > 0`. 

A similar bug occurs for each storage_variable in the contract that does not accept arguments (i.e. if the contract has a 0-argument variable named "foo", then the entity "foo" will appear as registered in the system).

**NOTE:** The malicious entity with name `"num_entities_storage"` appears as registired, but it will not be encountered when iterating thorugh the ...

## Possible patches
Any of the following patches would fix the bug described above.
### Patch 1
Use a storage variable as follows

        @storage_var
        func entity_name_to_entity_memory_key(entity_index) -> (memory_key:felt):
        end

This way, instead of storing `EntityInfo` in `sn_keccak256("entity_name")`, we store `EntityInfo` in `pedersen_hash(sn_keccak256("entity_name_to_entity_memory_key"), entity_index)`. Now, a similar attack as the one descibed above is infeasible since it would involve finding a collision for the Pedersen hash.

**NOTE:** In fact, this way of writing the contract is more natural than the one given by us. However it is reasonable to think that in some cases our initial design would be implemented: for example, our bugged design requires a smaller number of hash computations, or maybe the functionality in this contract is part of a more complex project and somehow the bugged implementation comes more naturally within the context of the entire project.

### Patch 2 
When selecting the memory cells where to store the entity information, use the Pedersen hash function instead of `sn_keccak256`, i.e. for an entity with name `entity_name`, store the struct `EntityInfo` in `pedersen_hash(0, entity_name)`.

