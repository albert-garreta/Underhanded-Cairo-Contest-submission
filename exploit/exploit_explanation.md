## Exploit explanation

Calling the function `is_entity_registered` with the input `num_entities_storage` returns a true value (i.e. it returns the felt 1) (assuming there is at least one other entity which is part of the network). Hence an attacking entity who is not part of the network can give itself the name `num_entities_storage` and access the contract's functionality since it will appear as a registered entity.

The reason why this happens is because a storage variable with name `variable_name` is stored in the cell `sn_keccak256(variable_name)`. Hence, as long as `num_entities_storage` is more than 0, `is_entity_registered(num_entitites_storage) = storage_read(sn_keccak(num_entitties_storage)) > 0`. 

## Possible patches
After implement any one of these patches, an attack similar to the one described above would essentially require find a collision for the hash functions `sn_keccak256` or the Pedersen hash function.
- When selecting the memory cells where to store the entity information, use the Pedersen hash function instead of `sn_keccak256`.
- Use a storage variable as follows
        @storage_var
        func entity_name_to_entity_memory_key(entity_index) -> (memory_key):
        end
This way, instead of storing `EntityInfo` in `sn_keccak256("entity_name")`, we store `EntityInfo` in `pedersen_hash(sn_keccak256("entity_name"), entity_index)`. Now, a similar attack as the one descibed above is infeasible since it would involve finding a collision for the Pedersen hash.

