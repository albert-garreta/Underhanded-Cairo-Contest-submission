## Exploit explanation

An entity named "total_number_of_registered_entities" will be accepted as registered by the function `is_entity_registired` (******footnore: more than one entity***). This opens the door to unexpected bugs ant to a malicious entity who chooses "total_number_of_registered_entities" as its name to use some of the network's privileges.

The reason why this happens is because the StakNet OS stores a 0-argument variable with name `variable_name` at the cell `sn_keccak256(variable_name)` (see ***reference***, here `sn_keccak256` means StarkNet's version of the Keccak256 hash function). Hence, as long as `total_number_of_registered_entities` is more than 0, we have `storage_read(sn_keccak(num_entitties_storage)) > 0`, and so `is_entity_registerd(sn_hash_of_"total_number_of_registered_entities") = 1`.

Similarly, for each 0-argument storage variable `foo` in the contract, an entity with name "foo" will pass as registered in the L2 contract, as long as `foo` stores a nonzero value.

## Bug test

The script `test_exploit.py` contains a test that checks that this bug occurs.

## Possible patch

Instead of storing the entity information in the hash of the entity's name, use a storage variable that maps entity names (or the `sn_keccak256` hashes of the names) to their corresponding instance of the struct EntityInfo.

This is perhaps the most natural way of writing the L2 contract to begin with. However as discussed in the README, it is reasonable to think that some developer would choose the bugged version due to it being slightly more efficient and because the bugged version is potentially more consistent with how the L1 contract is written.

More generally, when in doubt, it may be better to avoid using `sn_keccak256` hashes within a StarkNet contract.