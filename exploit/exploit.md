## Exploit explanation

An entity named "total_number_of_registered_entities" will be accepted as registered by the function `is_entity_registired` (******footnore: more than one entity***). This opens the door to unexpected bugs or to a malicious entity who chooses "total_number_of_registered_entities" as its name to  use some of the network's privileges.

The reason why this happens is because the StakNet OS stores a 0-argument variable with name `variable_name` at the cell `sn_keccak256(variable_name)` (***reference***). Hence, as long as `total_number_of_registered_entities` is more than 0, we have `storage_read(sn_keccak(num_entitties_storage)) > 0`, and so `is_entity_registerd(sn_hash_of_"total_number_of_registered_entities") = 1`.

Similarly, for each 0-argument storage variable `foo` in the contract, we have that an entity with name "foo" will pass as registered in the system, as long as `foo` stores a nonzero value.

## Bug test

The script `test_exploit.py` contains a test that checks that this bug occurs.

## Possible patch

Instead of storing the entity information in the hash of the entity's name, use a storage variable that maps entity names (or the `sn_keccak256` hashes of the names) to their corresponding instance of the struct EntityInfo.

This is perhaps the most natural way of writing the L2 contract to begin with. However as discussed in the README, it is reasonable to think that some developer would choose the bugged version due to it being slightly more efficient and because the bugged version is potentially more consistent with how the L1 contract is written.

## Conclusion

In general, it seems a good idea to avoid using `sn_keccak256` hashes in a StarkNet contract since this hash can introduce unexpected collisions with the cells where 0-argument storage variables are stored.
