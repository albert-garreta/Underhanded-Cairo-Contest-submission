"""contract.cairo test file."""
import os
import pytest
from starkware.starknet.testing.starknet import Starknet
from starkware.starknet.public.abi import starknet_keccak

# The path to the contract source code.
CONTRACT_FILE = os.path.join("contracts", "contract.cairo")

@pytest.mark.asyncio
async def test_exploit():
    # Create a new Starknet class that simulates the StarkNet
    # system.
    starknet = await Starknet.empty()

    # Deploy the contract.
    contract = await starknet.deploy(
        source=CONTRACT_FILE,
    )
    
    # Register an entity
    entity_name = "cool_entity"
    await register_entity(contract, entity_name = entity_name, data1 = 10, data2= 20)
    # Check thath the entity is registered
    assert await check_if_registered(contract, entity_name)
    
    # Check that some random other entity is not registered
    assert not await check_if_registered(contract, "other_cool_entity")

    # Check that there is exactly one entity registered, i.e. "cool_entity"
    execution_info = await contract.get_total_number_of_registered_entities().call()
    assert execution_info.result[0] == 1

    # But the entity called "total_number_of_registered_entities" appears as registered!
    assert await check_if_registered(contract, "total_number_of_registered_entities")
    
    # The entity called "foo" is not registered (yet) because its value is initialized to 0.
    # If the value were to increase, then it would also appear as registered (and so on 
    # with all 0-argument storage variables of the contract)
    assert not await check_if_registered(contract, "foo")


##########################
# Helper functions
##########################

async def register_entity(contract, entity_name: str, data1: int, data2: int):
    # This function uses the `DUMMY_register_entity` function from the cairo contract to register an entity
    
    # Entity names are identified with the integers obtained from their ascii encoding
    bytes_name = entity_name.encode("ascii") 
    int_name = int.from_bytes(bytes_name, "big")
    
    # Hash the name
    hash_of_name = starknet_keccak_wrapper(entity_name)
    
    # Register the entity
    await contract.DUMMY_register_entity(hash_of_name, int_name, data1, data2).invoke()
       
async def check_if_registered(contract : Starknet, entity_name: str)-> bool:
    # This function checks if an entity is registered in the L2 contract by calling the L2 contract function `is_entity_registered`
    hash_of_entity_name = starknet_keccak_wrapper(entity_name)
    execution_info = await contract.is_entity_registered(hash_of_entity_name).call()
    return execution_info.result[0]

def starknet_keccak_wrapper(name : str):
    # This is a wrapper around the function `starknet_keccak` which can hash a string
    return starknet_keccak(name.encode("ascii"))